---
title: "Simulating fossils"
author: "Rachel C. M. Warnock"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{FossilSim}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 5, fig.height = 5
)
```
```{r, echo = FALSE, results = "hide", message = FALSE}
devtools::load_all()
```

This vignette provides information about how the package stores and outputs information about fossil sampling times via the `fossils` object and available options for simulating fossil recovery.

## Contents

* [The fossils object]
* [Constant fossil recovery]
  * [Simulating fossils for a tree object]
  * [Simulating fossils for a taxonomy object]
* [Interval-dependent fossil recovery]
  * [Simulating fossils for a fixed number of intervals]
  * [Simulating fossils for a set of non-uniform intervals]
  * [Simulating fossils using per-interval probabilities]
  * [Incorporating stratigraphic age uncertainty]
* [Environment-dependent fossil recovery]
* [Lineage-dependent fossil recovery]
  * [The autocorrelated fossil recovery model]
  * [The independent fossil recovery model]
  * [The innovative fossil recovery model]
* [Extant species and tip sampling]

### The fossils object

The `fossils` object contains information about fossil sampling times and their relationship to the corresponding `phylo` and `taxonomy` objects. 
In some simulation conditions we may know the age of fossils precisely.
Alternatively, there may be some uncertainty associated with specimen ages, i.e. we only know the age to within some stratigraphic interval, which can be incorporated into the `fossils` object.

The object contains a dataframe with species and age information for each fossil with the following 4 fields:

* `sp` the label of the corresponding species. This label matches the edge labels in the corresponding phylogeny if no additional taxonomic information was provided or the species labels in the corresponding taxonomy object

* `edge` the label of the sampled node or tip in the phylogeny, i.e the node at the end of the edge along which the fossil was sampled

* `hmin` the age of the fossil or the youngest bound of the time interval in which the fossil was sampled

* `hmax` the oldest bound of the time interval in which the fossil was sampled. This is equal to `hmin` if exact sampling times are known

The object also contains a logical variable `from.taxonomy` indicating whether the fossil record was simulated using a `taxonomy` object, in which case `from.taxonomy = TRUE`, or from a `phylo` object in which case `from.taxonomy = FALSE` (the default).

## Constant fossil recovery

The simplest model of fossil recovery is a Poisson sampling process, where fossils are sampled along lineages with constant rate $\psi$ (parameter `rate` below).

Fossils can be simulated using a `phylo` object or an existing `taxonomy` object generated using the function `sim.taxonomy`.

### Simulating fossils for a tree object

If a `phylo` rather than a `taxonomy` object is passed to the function, it will assume that all speciation has occurred via symmetric (i.e. bifurcating, $\beta = 1$) speciation, i.e. every edge in the tree represents a unique species.
This applies to all functions used to simulate fossils.

```{r}
# set the random number generator seed to generate the same results using the same code
set.seed(1234)

# simulate a tree using TreeSim conditioned on tip number
lambda = 1
mu = 0.2
tips = 8
t = TreeSim::sim.bd.taxa(tips, 1, lambda, mu)[[1]]
# t is an object of class phylo
t
# use t$edge, t$edge.length, t$root.edge to see the tree attributes

# Simulate fossils
rate = 3 # poisson sampling rate
f = sim.fossils.poisson(rate = rate, tree = t)
f
```

Each entry in the `fossils` dataframe corresponds to a fossil sampling time.
`sp` and `edge` are the species and edge labels, respectively, which will be the same since we assume symmetric speciation.

`hmin` and `hmax` are the youngest and oldest sampling ages associated with each fossil, respectively.
Since this function returns exact fossil sampling times `hmin` and `hmax` are equal.

```{r} 
# plot fossil occurrences
plot(f, t)
```
```{r}
# plot fossil stratigraphic ranges
plot(f, t, show.ranges = TRUE)
```

### Simulating fossils for a taxonomy object
```{r}
# simulate taxonomy under mixed speciation
beta = 0.5 # probability of symmetric speciation
lambda.a = 1.2 # rate of anagenetic speciation
s = sim.taxonomy(t, beta = beta, lambda.a = lambda.a)

# simulate fossils
f = sim.fossils.poisson(rate = rate, taxonomy = s)
f

# plot the output and color fossils by taxonomy
plot(f, t, taxonomy = s, show.taxonomy = TRUE)
```

Note that `sp` and `edge` are not all equal, since some species are assigned to multiple edges, and some edges are associated with multiple species.

## Interval-dependent fossil recovery

PLOT SOME PROXY DATA

Under the interval-dependent model, fossil recovery changes in a piece-wise manner across a set of user defined intervals.
Interval ages can be specified using a fixed set of uniform length intervals, by passing the function the maximum interval age (`max.age`) and the number of intervals (`strata`), or a vector of non-uniform intervals (`interval.ages`).

The function `tree.max` can be used to assign a maximum age based on tree age. If the tree has a `root.edge` the function will return the origin time, otherwise the function returns the root age.

### Simulating fossils for a fixed number of intervals

```{r}
# define max interval age based on tree age
max.age = tree.max(t)

# define the number of intervals
strata = 4

# TODO revisit the wording here
# define a vector of sampling rates from youngest to oldest
rates = c(1, 0.1, 1, 0.1)

# simulate fossils
f = sim.fossils.intervals(t, rates = rates, max.age = max.age, strata = strata)
 
# plot the output
plot(f, t, show.strata = TRUE, strata = strata)
```

If no maximum is provided to the plotting function and `strata` > 1, the function `tree.max` is used to define `max.age`.

### Simulating fossils for a set of non-uniform intervals
```{r}
# the following will sample a random set of interval ages between 0 and max.age
times = c(0, sort(runif(3, min = 0, max = max.age)), max.age)

# define a vector of sampling rates from youngest to oldest
rates = c(1, 0.1, 1, 0.1)

# simulate fossils
f = sim.fossils.intervals(t, rates = rates, interval.ages = times)
 
# plot the output
plot(f, t, show.strata = TRUE, interval.ages = times)
```

### Simulating fossils using per-interval probabilities

Fossil recovery can also be specified using a set of per-interval probabilities. 
Using this approach at most one fossil per species will be sampled per interval.

```{r}
# define max interval age based on tree age
max.age = tree.max(t)

# define the number of intervals
strata = 4

# define a vector of sampling probabilities from youngest to oldest
probabilities = c(1.0, 0.5, 0.2, 0.1)

# simulate fossils
f = sim.fossils.intervals(t, probabilities = probabilities, max.age = max.age, strata = strata)
 
# plot the output
plot(f, t, show.strata = TRUE, strata = strata)
```

### Incorporating stratigraphic age uncertainty

To incorporate age uncertainty into the output using the function `sim.fossils.intervals` set `use.exact.times = FALSE`.
In this case `hmin` and `hmax` will represent the youngest and oldest age associated with the fossil, respectively.
When we plot the output the function will place the fossils at the mid-point of the corresponding interval.
This means in some cases fossils will not appear along their corresponding edge.

```{r}
# simulate fossils
f = sim.fossils.intervals(t, probabilities = probabilities, max.age = max.age, strata = strata, use.exact.times = FALSE)
f

# plot the output
plot(f, t, show.strata = TRUE, strata = strata)
```

Alternatively, if you simulate fossils using a function that only returns exact fossil sampling times, e.g. using the `sim.fossils.poisson` function, you can later assign fossils to different intervals using the `sim.interval.ages` function.
You can also generate output using this function that respect the species duration times by setting `use.species.ages = TRUE`, i.e. the function will not return a value for `hmin` or `hmax` that are younger or older than the true species age.
To use this option you also need to pass a `phylo` or `taxonomy` object to function.

```{r}
# simulate fossils
f = sim.fossils.poisson(t, rate = 3)

# reassign fossils to intervals
f = sim.interval.ages(f, tree = t, max.age = max.age, strata = strata, use.species.ages = TRUE)

# plot the output
plot(f, t, show.strata = TRUE, strata = strata)
```

## Environment-dependent fossil recovery

NAME THE FUNCTION

The variables that control the distribution and abundance of species also control depositional environment, meaning observed changes in deposition reflect changes in environmental or ecological gradient across the same area.
A species response curve, which describes the abundance of a species relative to an environmental gradient, can therefore be used to model distributions of fossil occurrences.

Holland (1995) described a three parameter Gaussian model for simulating environment-dependent fossil recovery.
\todo add citation
In this model each species has three parameters, species preferred depth (`PD`), depth tolerance (`DT`) and peak abundance (`PA`). 
See the plot below for examples.
The probability of fossil recovery during a given interval of time is a function of water depth, given by,

$Pr_{collection_i}(d) = PA * exp(-(d - PD)^2/ (2*DT^2))$,

where `d` is current water depth, `PD` and `DT` are the mean and the standard deviation of the distribution, respectively, and `PA` describes the amplitude of the distribution.
Here the model is described in the context of marine taxa, however the model and the function `sim.fossils.environment` can be applied to any enviromental or depositional context, in which some measure of environmental gradient can be generated. 

The following code snippet illustrate how to explore the role of the model parameters `PD`,`DT` and `PA` in determining species response curves.

```{r}
# define a set of colors for 4 species
# color palette chosen using RColorBrewer
cols = c("#E41A1C", "#377EB8", "#984EA3", "#4DAF4A") 

# species response curve function
response.curve = function(x) PA * exp(-(x - PD)^2/ (2*DT^2))

# define species variables # species 1
PA = 1 # peak abundance
PD = 2 # preferred depth
DT = 1 # depth tolerance

# plot species resonse curve
curve(response.curve, -2, 6, bty = "n", xlab = "relative depth", ylab = "Pr(collection)", xlim = c(-6,6), lwd = 1.5, col = cols[1])

# redefine depth tolerance and compare the output # species 2
DT = 0.5
curve(response.curve, -1, 5, add = TRUE, lwd = 1.5, col = cols[2])

# redefine preferred depth and compare the output # species 3
PD = -2
curve(response.curve, -5, 1, add = TRUE, lwd = 1.5, col = cols[3])

# redefine prferred depth and peak abundance # species 4
PD = -4
PA = 0.5
curve(response.curve, -6, -2.2, add = TRUE, lwd = 1.5, col = cols[4])
```

In the following example fossil occurences are simualted for a vector of gradient values generated using the function `sim.gradient`, which return values for the following simple sine wave function,
$y = d*sin(cycles*pi*(x-1/4))$, where $x$ is the number of intervals or strata.
The function output can be used to represent changes in relative water depth, where the cycles are equivalent to the number of trangression/regression events.

The user is free to use a vector of any gradient values. 

Intervals can be specified in the same way as the function `sim.fossils.intervals` via `max.age` and `strata` or the `intervals` vector.

```{r, fig.show="hold"}
# define the interval parameters
strata = 20
times = seq(0, tree.max(t), length.out = strata+1)

# simulate gradient values
wd = sim.gradient(strata, depth = 6)

# wd is a vector representing relative water depth
wd

# define species trait values # species 1
PD = 1
DT = 2
PA = 1

# simulate fossils
f = sim.fossils.environment(t, interval.ages = times, proxy.data = wd, PD = PD, DT = DT)

# plot output and include proxy data & preferred depth
plot(f, t, interval.ages = times, show.strata = TRUE, show.proxy = TRUE, proxy.data = wd, show.preferred.environ = TRUE, preferred.environ = PD, fossil.col = cols[1])

# redefine species trait values # species 2
DT = 0.5

# simulate fossils
f = sim.fossils.environment(t, interval.ages = times, proxy.data = wd, PD = PD, DT = DT)

# plot output
plot(f, t, interval.ages = times, show.strata = TRUE, show.proxy = TRUE, proxy.data = wd, show.preferred.environ = TRUE, preferred.environ = PD, fossil.col = cols[2])

# redefine species trait values # species 3
PD = -2

# simulate fossils
f = sim.fossils.environment(t, interval.ages = times, proxy.data = wd, PD = PD, DT = DT)

# plot output
plot(f, t, interval.ages = times, show.strata = TRUE, show.proxy = TRUE, proxy.data = wd, show.preferred.environ = TRUE, preferred.environ = PD, fossil.col = cols[3])

# define species trait values # species 4
PD = -4
PA = 0.5

# simulate fossils
f = sim.fossils.environment(t, interval.ages = times, proxy.data = wd, PD = PD, DT = DT)

# plot output
plot(f, t, interval.ages = times, show.strata = TRUE, show.proxy = TRUE, proxy.data = wd, show.preferred.environ = TRUE, preferred.environ = PD, fossil.col = cols[4])
```

## Lineage-dependent fossil recovery

Variation in fossil recovery parameters across different lineages or species can be generated using the function `sim.trait.values`. Simulated trait values can then be used to define the parameters in the functions `sim.fossils.poisson` and `sim.fossils.environment`.

\todo input

### The autocorrelated fossil recovery model

Under the `autocorrelated` model, traits evolve along lineages according to a a Brownian motion process, where the strength of the relationship between ancestor and descendant values is determined by the parameter $\nu$ (function argument `v`).
If $\nu$ is small values will be more similar between ancestor and descendants, and if $\nu$ is zero all trait values will be equal.
New rates are drawn from a lognormal distribution with ...
\todo cite Heath et al. (2014) 
This is equivalent to the autocorrelated relaxed clock model described in Kishino et al. (2001). \todo add citation.

```{r}
# simulate trait values under the autocorrelated model (the default model)
rate = 1 # initial rate at the root or origin
rates = sim.trait.values(rate, tree = t, v = 0.01)
# TODO rates are ordered
rates

# simulate fossils
f = sim.fossils.poisson(t, rate = rates)

# plot the output
plot(f, t)
```

### The independent fossil recovery model

Under the `independent` model a new trait value is drawn for each species from any valid user-specified distribution `dist`.
To be valid the function just has to return a single value.

```{r}
# define the initial value at the root or origin
rate = 1 

# define the distribution used to sample new rates
# in this case an exponential with a mean = 1
dist = function() { rexp(1) }

# simulate trait values under the independent traits model
rates = sim.trait.values(rate, tree = t, model = "independent", dist = dist)

# simulate fossils
f = sim.fossils.poisson(t, rate = rates)

# plot the output
plot(f, t)
```

### The innovative fossil recovery model

Under the `innovative` model changes in trait values are coincident with speciation events.
At each speciation event change occurs with probability `change.pr` and new values are drawn from any valid user-specified distribution `dist`.

```{r}
# define the initial value at the root or origin
rate = 1

# define the distribution used to sample new rates
# in this case an exponential with a mean ~ 3
dist = function() { rexp(1, 1/4) }

# define the probability of the trait value changing at each speciation event
change.pr = 0.5

# simulate trait values under the independent traits model
rates = sim.trait.values(rate, tree = t, model = "innovative", dist = dist)

# simulate fossils
f = sim.fossils.poisson(t, rate = rates)

# plot the output
plot(f, t)
```

### Environment and lineage-dependent fossil recovery

Lineage specific values generated using `sim.trait.values` can also be passed to the the function `sim.fossils.environment` to define the `PD`, `DT`, and `PA` parameters.

```{r}
# define constant values for preferred depth and depth tolerance
PD = 2
DT = 0.5

# simulate lineage variable peak abundance values
#TODO change rate to root.value
PA 

# simualte fossils


```

## Extant species and tip sampling

The functions X and X can be used to simulate incomplete extant species or tip sampling. The parameter `rho` is the probability that an extant species or tip with be sampled.

```{r}
# simualte fossil

# simulate extant species sampling

# plot the output

# simulate tip sampling
  
```
